# トークンの処理フロー

トークンの具体的な処理については[tokens/](tokens/)を参照する

## インライントークン

### 子要素なし

1. 開始フラグを立てる
2. 開始トークンから終了トークンに向かって一文字単位で走査する
3. 終了トークンがない場合、終了フラグを立てないまま終わる

### 子要素あり

1. 開始トークンを見つけたら、そこから一文字読み込み、カーソルを進める
2. 別のトークンが出現したら、別のトークンの処理を開始する
3. 改行か終了トークンが現れたら終了する

## ブロックトークン

分類できない文字列は全てParagraphブロックに属する

### 子要素なし

1. 開始フラグを立てる
2. 開始トークンから終了トークンに向かってひたすら文字列を行単位で取得する
3. 終了トークンがない場合、終了フラグを立てないまま終わる

### 子要素あり

1. 開始トークンを見つけたら、そこから一文字読み込み、カーソルを進める
2. 別のトークンが出現したら、別のトークンの処理を開始する
3. 終了トークンが現れたら終了する
    1. 終了トークンがない場合、終了フラグを立てないまま終わる

## エスケープ

-   `\`がある場合、次の文字列のトークンマッチングを行わない
-   但しcode or codefenceのテキスト中に出現した場合、無視する

## 子要素がある場合のデータ構造

### ネスト処理の一例

同一要素がネストされていることは考慮しない

`**ああああ*いいい*ううう**`

```json
{
    "type": "bold",
    "text": "ああああ",
    "is_open": 1,
    "is_close": 0,  // 子の側で閉じているのをどうやって把握するか…
    "tokens": [
        {
            "type": "italic",
            "text": "いいい",
            "is_open": 1,
            "is_close": 1,
            "tokens": [
                {
                    "type": "bold",
                    "text": "ううう",
                    "is_open": 1, // これはコールスタックからどうにかして階層のどこかに開いている情報をとって実現する
                    "is_close": 1, // このシーケンスで閉じることが分かっているので設定できる
                    "tokens": []
                }
            ]
        }
    ]
}
```

### 課題

#### 閉じ判定をどうするか

```
`**ああああ*いいい*う*う*う**`
<strong>ああああ<em>いいい</em>う<em>う</em>う</strong>
```

```
`**ああああ*いいい*う*うう**`
<strong>ああああ<em>いいい</em>う*うう</strong>
```
